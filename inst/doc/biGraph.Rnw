\documentclass{article}

\usepackage{amsmath}
\usepackage{amscd}
\usepackage[tableposition=top]{caption}
\usepackage{ifthen}
%\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{authblk}


\begin{document}
%\VignetteIndexEntry{biGraph}
\SweaveOpts{keep.source=FALSE}
\title{The biGraph--package\\[.5cm] \normalsize \texttt{Version 0.9-3}}
\author{Ingo Vogt}
\affil{Chemogenomics Laboratory, Research Unit on Biomedical Informatics, Municipal Institute of Medical Research (IMIM) and University Pompeu Fabra, Parc de Recerca Biom\`edica, Doctor Aiguader 88, 08003 Barcelona, Catalonia, Spain}
\maketitle

This package is an extension to the \emph{igraph}--package \cite{Csardi2006} and provides a set of tools specifically aimed at the analysis of bipartite graphs. While intended to be continuously extended regarding functionality, the current focus lies on the projection of bipartite graphs, specifically concerning the associated information loss. In addition, clustering and community detection among vertex subsets is supported by providing metric distance calculations based on flexible (weighted) neighbourhoods.

\section{Projection of bipartite graphs}
In \emph{bipartite} graphs, vertices are distinguished into \emph{top} and \emph{bottom} ($\top$ and $\bot$) set and edges only occur between these two sets.

As example we examine a very small bipartite graph where vertices resemble diseases and genes thought to be involved some of these diseases.
<<reg>>==
library(biGraph)
data(g)
summary(g)
@
The vertex attribute \verb@type@ was derived in advanced by using the \emph{igraph}--function \verb@is.bipartite@, and this logical attribute identifies both vertex subsets.
<<reg>>==
V(g)[type==TRUE]
V(g)[type==FALSE]
@
The depiction of this bipartite graph shown in Figure~\ref{fig:one_b} (p.~\pageref{fig:one_b}) can be generated by
<<label=fig1_plot,include=FALSE>>=
plot(g,layout=layout.fruchterman.reingold,vertex.label=gsub('_','\n',V(g)$dname),vertex.color=V(g)$col,vertex.label.color='black',vertex.label.dist=0.5,vertex.label.family='Helvetica',vertex.label.cex=0.6, edge.label.cex=0.6)
@
\begin{figure}
\begin{center}
<<label=fig1_b,fig=TRUE,echo=FALSE>>=
<<fig1_plot>>
@
\end{center}
\caption{Bipartite gene--disease graph, names of genes (smaller white circles) are omitted for better readability}
\label{fig:one_b}
\end{figure}

 Often, it is desired to derive a monopartite projection regarding one vertex subset, where vertices belonging to this selected set are connected by an edge if they are connected to at least one vertex of the other vertex subset.

For this purpose, \emph{igraph} provides the function \verb@bipartite.projection@, that generates both projections, from which the disease projection is shown in Figure~\ref{fig:two_b} (p.~\pageref{fig:two_b})
<<label=fig2_plot,include=FALSE>>=
proj <- bipartite.projection(g)
plot(proj[[2]],layout=layout.fruchterman.reingold,vertex.label=gsub('_','\n',V(g)[type==TRUE]$name),vertex.color=V(g)[type==TRUE]$col,vertex.label.color='black',vertex.label.dist=0.5,vertex.label.family='Helvetica',vertex.label.cex=0.6, edge.label.cex=0.6)
@
\begin{figure}
\begin{center}
<<label=fig2_b,fig=TRUE,echo=FALSE>>=
<<fig2_plot>>
@
\end{center}
\caption{Monopartite projection for disease vertices}
\label{fig:two_b}
\end{figure}
However, this projection comes not without a loss of information as discussed in \cite{Montanez2010, Vogt2010, Klamt2009, Zhang2008, Latapy2006}. In order to allow the quantification of this information loss two approaches are presented in \cite{Vogt2010a}, which are implemented in \emph{biGraph} by function \verb@bipartite.projection.informationloss@.

\subsection{Assessing information loss}
In \emph{biGraph}, function \verb@bipartite.projection.informationloss@ generates the desired projection(s) and subsequently measures the information loss according to the user selection.
\begin{itemize}
 \item \verb@graph.dH@: Change in uncertainty for entire graph
 \item \verb@vertex.dH@: Change in uncertainty for single vertices
 \item \verb@edge.dH@: Change in uncertainty for single edges
 \item \verb@covLoss@: Loss of coverage for single edges, leads to automatic calculation of vertex attribute \verb@avCovLoss@
\end{itemize}
As a shortcut, \verb@measures='complete'@ selects all measures at once.
<<reg>>==
proj <- bipartite.projection.informationloss(g,vType=TRUE,measures='complete')
proj[[1]]$H.delta
summary(V(proj[[1]])$H.delta)
summary(E(proj[[1]])$H.delta)
summary(E(proj[[1]])$covLoss)
summary(V(proj[[1]])$avCovLoss)
@

Figure~\ref{fig:nine_b} (p.~\pageref{fig:nine_b}) shows the monopartite disease projection where information loss measurements are visualized. If multiple cpus or cores are locally available, it is recommended to install the \verb@multicore@--package and enable parallel computation via setting \verb@parall=TRUE@ and \verb@cores@ as desired. To facilitate the analysis of information loss e.g. by means of Figure~\ref{fig:seven_b} (p.~\pageref{fig:seven_b}), attributes \verb@H.before@ and \verb@H.after@ are also assigned to the corresponding graph entities when measuring the change in uncertainty.
<<label=fig9_plot,include=FALSE,echo=FALSE>>=
plot(proj[[1]],layout=layout.fruchterman.reingold,vertex.label=gsub('_','\n',V(proj[[1]])$name),vertex.color=V(g)[type==TRUE]$col,vertex.label.color='black',vertex.label.dist=0.5,vertex.label.family='Helvetica',vertex.label.cex=0.6, edge.label.cex=0.6,vertex.size=(V(proj[[1]])$H.after*3)+2,edge.width=(E(proj[[1]])$covLoss*5)+1)
@
\begin{figure}
\begin{center}
<<label=fig9_b,fig=TRUE,echo=FALSE>>=
<<fig9_plot>>
@
\end{center}
\caption{Monopartite disease projection. Vertex size and edge width are scaled by increase in uncertainty and loss of coverage, respectively.}
\label{fig:nine_b}
\end{figure}

<<label=fig7_plot,include=FALSE>>=
plot(V(proj[[1]])$H.before,V(proj[[1]])$H.after,xlab='Uncertainty before projection [nats]',ylab='Uncertainty after projection [nats]',pch=20,cex=1.5,xlim=c(0,4),ylim=c(0,4))
@
\begin{figure}
\begin{center}
<<label=fig7_b,fig=TRUE,echo=FALSE>>=
<<fig7_plot>>
@
\end{center}
\caption{Comparison of uncertainty associated to vertices before and after projection}
\label{fig:seven_b}
\end{figure}

\subsection{Generating weighted projections}
If desired, one can generate a projection where graph entities are assigned a weight, whether it is based on some properties derived from the original bipartite graph or other sources. This functionality is implemented in function \verb@get.weighted.projection@. Currently only edge weights are supported, with one built--in weighting scheme and the possibility to provide an externally calculated weight matrix.

Apart from taking the number of shared neighbours in the bipartite graph also the weighting scheme for collaboration networks introduced by Newman \cite{Newman2001b} has been implemented. In Figure~\ref{fig:three_b} (p.~\pageref{fig:three_b}) the disease projection is shown with the number of shared neighbours as edge weights.
<<label=fig3_plot,include=FALSE>>=
proj_weighted <- get.weighted.projection(g,vType=TRUE,mode='shared-neighbours')
plot(proj_weighted,layout=layout.fruchterman.reingold,vertex.color=V(g)[type==TRUE]$col,vertex.label='',vertex.label.family='Helvetica',edge.label.family='Helvetica',edge.label=E(proj_weighted)$weight,vertex.label.cex=0.6, edge.label.cex=0.6,vertex.label.dist=0.5)
@
\begin{figure}
\begin{center}
<<label=fig3_b,fig=TRUE,echo=FALSE>>=
<<fig3_plot>>
@
\end{center}
\caption{Disease projection with number of shared neighbours as edge weights}
\label{fig:three_b}
\end{figure}

\clearpage
\section{Linkage patterns}
As one of the basic principles introduced in \cite{Vogt2010a}, linkage patterns in the context of projected monopartite graphs are defined as the different neighbourhoods of order 1 of vertices that are omitted during projection.
<<reg,keep.source=TRUE>>==
lpi(g,vType=FALSE)
@
Here, we observe 17 linkage patterns found among genes, of which pattern three and five occur twice, as mirrored by the corresponding source observations. There are three different modes for the generation of the linkage pattern information: \verb@full@ (default), \verb@basic@, and \verb@minimal@, where the last two increasingly discard the information on occurrences and sources. Via \verb@write.lpi@ the given linkage pattern information can be written to file, and read back via \verb@read.lpi@.
<<label=fig4_plot,include=FALSE>>=
write.lpi(lpi(g,vType=FALSE,mode='minimal'),'minimal.lpi')
lp <- read.lpi('minimal.lpi')
for (i in V(lp$graph)){c<-V(g)[which(V(g)$name==V(lp$graph)[i]$name)-1]$col; if(length(c)>0){V(lp$graph)[i]$col=c;V(lp$graph)[i]$size=10}else{V(lp$graph)[i]$col='white';V(lp$graph)[i]$size=5}}
plot(lp$graph,layout=layout.fruchterman.reingold,vertex.label=gsub('_','\n',V(lp$graph)$name),vertex.label.family='Helvetica',vertex.label.cex=0.6, edge.label.cex=0.6,vertex.label.color='black',vertex.label.dist=0.5,vertex.color=V(lp$graph)$col,vertex.size=V(lp$graph)$size)
@
\begin{figure}
\begin{center}
<<label=fig4_b,fig=TRUE,echo=FALSE>>=
<<fig4_plot>>
@
\end{center}
\caption{Reconstructed minimal bipartite graph.}
\label{fig:four_b}
\end{figure}
As can be seen in Figure~\ref{fig:four_b} (p.~\pageref{fig:four_b}), gene vertices have been replaced by vertices representing a linkage pattern each. If \verb@mode='basic'@ is chosen, only the names of omitted vertices will be discarded and the reconstructed graph and the original bipartite graph will be isomorphic. This could e.g. be useful if one would like to share the basic graph structure while withholding the identity of omitted vertices.
<<reg>>==
write.lpi(lpi(g,vType=FALSE,mode='basic'),'basic.lpi')
lp <- read.lpi('basic.lpi')
graph.isomorphic(g,lp$graph)
@


\clearpage
\section{Analytical tools for bipartite graphs}
Many tools that are used to study the properties of monopartite graphs cannot be directly applied to bipartite graphs. However, over the last decade, for some of these tools adaptions or analogous concepts have been devised, that nevertheless remain mostly unused and are usually missing from widely--used network and graph analysis suites. Apart from new developments, \emph{biGraph} is also intended to collect those as well. In this first release we implemented some of these tools published by Borgatti and Everett \cite{Borgatti1997}, compassing measures for density, vertex centrality, and centralization with respect to each vertex subset.

\subsection{Density}
Density measures the number of edges present in a graph, usually as ratio of present over the number of all possible edges. \emph{igraph} already provides a method to calculate the density of monopartite graphs, yet in bipartite graphs one has to take into account that vertices can only be connected to vertices in the other subset. In \emph{biGraph} this is implemented in function \verb@bipartite.graph.density@.\\[.5cm]
Density of bipartite graph according to function in \emph{igraph}:
<<reg>>==
graph.density(g)
@
Density of bipartite graph according to adapted function in \emph{biGraph}:
<<reg>>==
bipartite.graph.density(g)
@

\subsection{Vertex centrality}
In graph and network analysis, vertex centrality measures are applied in order to determine the relative importance of vertices. The most widely used centrality measure are degree, closeness, betweenness, and eigenvector centrality. Currently, the adaption to bipartite graphs have been implemented for the first three measures. A visualization of the bipartite betweenness centrality scores is depicted in Figure~\ref{fig:eight_b} (p.~\pageref{fig:eight_b}).
<<reg>>==
degree.centrality(g)
bipartite.closeness.centrality(g)
bipartite.betweenness.centrality(g)
@
As degree centrality is currently not implemented in \emph{igraph}, \verb@degree.centrality@ can also be applied to monopartite graphs.

<<label=fig8_plot,include=FALSE,echo=FALSE>>=
plot(g,layout=layout.fruchterman.reingold,vertex.label=gsub('_','\n',V(g)$dname),vertex.color=V(g)$col,vertex.label.color='black',vertex.label.dist=0.5,vertex.label.family='Helvetica',vertex.label.cex=0.6, edge.label.cex=0.6,vertex.size=((10*bipartite.betweenness.centrality(g)[[1]])+2)*1.5)
@
\begin{figure}
\begin{center}
<<label=fig8_b,fig=TRUE,echo=FALSE>>=
<<fig8_plot>>
@
\end{center}
\caption{Bipartite gene--disease graph, vertex sizes are scaled by bipartite betweenness centrality.}
\label{fig:eight_b}
\end{figure}

\subsection{Centralization}
Graph centralization quantifies to which extent a graph resembles a star, that is, contains a highly central vertex around which highly peripheral neighbour vertices are gathered \cite{Borgatti1997}. As discussed in several publications \cite{Vogt2010a, Borgatti1997}, projecting bipartite to monopartite graphs prior to analysis leads probably to biased results due to the loss of information associated with the projection scheme. Therefore, applying single mode centralization measures that determine the extent to which vertices in one subset are central relative only to other vertices within the same subset avoids this problem.\\[.5cm]
Based on the adapted vertex centrality measures, \emph{biGraph} provides three single mode graph centralization measures.
<<reg>>==
single.mode.degree.centralization(g)
single.mode.closeness.centralization(g)
single.mode.betweenness.centralization(g)
@
For the given example, we observe from the results that according to all three centralization measures disease vertices are more centralized than gene vertices.


\clearpage

\bibliographystyle{pnas2010}
\bibliography{MyCollection}

\end{document}

